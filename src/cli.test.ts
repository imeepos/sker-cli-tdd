/**
 * üî¥ TDD Á∫¢Èò∂ÊÆµÔºöCLI Â∑•ÂÖ∑ÊµãËØï
 * ÊµãËØïÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑ÁöÑÊ†∏ÂøÉÂäüËÉΩ
 */

import { CLI } from './cli';
import { MCPAIClient } from './mcp-ai-client';

// Mock Â§ñÈÉ®‰æùËµñ
jest.mock('./mcp-ai-client');
jest.mock('fs');
jest.mock('inquirer');

describe('CLI Â∑•ÂÖ∑', () => {
  let cli: CLI;
  let mockAIClient: jest.Mocked<MCPAIClient>;

  beforeEach(() => {
    // ÈáçÁΩÆÊâÄÊúâ mock
    jest.clearAllMocks();

    // ÂàõÂª∫ mock AI ÂÆ¢Êà∑Á´Ø
    mockAIClient = {
      provider: 'openai',
      configuration: {
        provider: 'openai',
        apiKey: 'test-key',
        model: 'gpt-4',
        temperature: 0.7,
        maxTokens: 4096,
      },
      client: {} as any,
      chatCompletion: jest.fn(),
      chatCompletionStream: jest.fn().mockReturnValue(
        Promise.resolve({
          [Symbol.asyncIterator]: async function* () {
            yield { choices: [{ delta: { content: 'test' } }] };
          },
        })
      ),
      chatCompletionWithTools: jest.fn(),
      executeToolCall: jest.fn(),
      getAvailableTools: jest.fn().mockReturnValue([]),
      validateConfig: jest.fn().mockReturnValue(true),
      testConnection: jest.fn().mockResolvedValue(true),
      getModelInfo: jest.fn().mockResolvedValue({}),
      switchProvider: jest.fn(),
    } as any;

    // ÂàõÂª∫ CLI ÂÆû‰æã
    cli = new CLI();
  });

  describe('ÂàùÂßãÂåñ', () => {
    it('Â∫îËØ•ËÉΩÂ§üÂàõÂª∫ CLI ÂÆû‰æã', () => {
      expect(cli).toBeInstanceOf(CLI);
    });

    it('Â∫îËØ•ËÉΩÂ§üËÆæÁΩÆ AI ÂÆ¢Êà∑Á´Ø', () => {
      cli.setAIClient(mockAIClient);
      expect(cli.getAIClient()).toBe(mockAIClient);
    });
  });

  describe('ÈÖçÁΩÆÁÆ°ÁêÜ', () => {
    it('Â∫îËØ•ËÉΩÂ§üÂä†ËΩΩÈªòËÆ§ÈÖçÁΩÆ', () => {
      const config = cli.getDefaultConfig();
      expect(config).toHaveProperty('model');
      expect(config).toHaveProperty('temperature');
      expect(config).toHaveProperty('maxTokens');
    });

    it('Â∫îËØ•ËÉΩÂ§ü‰ªéÁéØÂ¢ÉÂèòÈáèÂä†ËΩΩÈÖçÁΩÆ', () => {
      process.env['AI_API_KEY'] = 'test-api-key';
      process.env['AI_MODEL'] = 'gpt-3.5-turbo';

      const config = cli.loadConfigFromEnv();
      expect(config.apiKey).toBe('test-api-key');
      expect(config.model).toBe('gpt-3.5-turbo');

      // Ê∏ÖÁêÜÁéØÂ¢ÉÂèòÈáè
      delete process.env['AI_API_KEY'];
      delete process.env['AI_MODEL'];
    });

    it('Â∫îËØ•‰ªéConfigManagerËé∑ÂèñÈÖçÁΩÆ', () => {
      const config = cli.loadConfigFromEnv();
      expect(config).toBeDefined();
      expect(config.provider).toBeDefined();
      expect(config.apiKey).toBeDefined();
    });
  });

  describe('ÂëΩ‰ª§Ë°åÂèÇÊï∞Ëß£Êûê', () => {
    it('Â∫îËØ•ËÉΩÂ§üËß£ÊûêÂü∫Êú¨ÂëΩ‰ª§Ë°åÂèÇÊï∞', () => {
      const args = ['--model', 'gpt-4', '--temperature', '0.7'];
      const options = cli.parseArgs(args);

      expect(options.model).toBe('gpt-4');
      expect(options.temperature).toBe(0.7);
    });

    it('Â∫îËØ•ËÉΩÂ§üËß£ÊûêÊµÅÂºèËæìÂá∫ÈÄâÈ°π', () => {
      const args = ['--stream'];
      const options = cli.parseArgs(args);

      expect(options.stream).toBe(true);
    });

    it('Â∫îËØ•ËÉΩÂ§üËß£Êûê‰∫§‰∫íÂºèÊ®°ÂºèÈÄâÈ°π', () => {
      const args = ['--interactive'];
      const options = cli.parseArgs(args);

      expect(options.interactive).toBe(true);
    });

    it('Â∫îËØ•Â§ÑÁêÜÊó†ÊïàÁöÑÊ∏©Â∫¶ÂÄº', () => {
      const args = ['--temperature', ''];
      const options = cli.parseArgs(args);

      expect(options.temperature).toBeUndefined();
    });

    it('Â∫îËØ•Â§ÑÁêÜÊó†ÊïàÁöÑÊúÄÂ§ß‰ª§ÁâåÊï∞ÂÄº', () => {
      const args = ['--max-tokens', ''];
      const options = cli.parseArgs(args);

      expect(options.maxTokens).toBeUndefined();
    });

    it('Â∫îËØ•Â§ÑÁêÜÁ©∫ÁöÑÊ∏©Â∫¶ÂÄº', () => {
      const args = ['--temperature', ''];
      const options = cli.parseArgs(args);

      expect(options.temperature).toBeUndefined();
    });

    it('Â∫îËØ•Â§ÑÁêÜÁ©∫ÁöÑÊúÄÂ§ß‰ª§ÁâåÊï∞ÂÄº', () => {
      const args = ['--max-tokens', ''];
      const options = cli.parseArgs(args);

      expect(options.maxTokens).toBeUndefined();
    });

    it('Â∫îËØ•Â§ÑÁêÜÁº∫Â∞ëtemperatureÂèÇÊï∞ÂÄºÁöÑÊÉÖÂÜµ', () => {
      const args = ['--temperature'];
      const options = cli.parseArgs(args);
      expect(options.temperature).toBeUndefined();
    });

    it('Â∫îËØ•Â§ÑÁêÜÁº∫Â∞ëmax-tokensÂèÇÊï∞ÂÄºÁöÑÊÉÖÂÜµ', () => {
      const args = ['--max-tokens'];
      const options = cli.parseArgs(args);
      expect(options.maxTokens).toBeUndefined();
    });

    it('Â∫îËØ•Ëß£ÊûêÂ∏ÆÂä©ÂèÇÊï∞ÁöÑÁÆÄÂÜôÂΩ¢Âºè', () => {
      const args = ['-h'];
      const options = cli.parseArgs(args);

      expect(options.help).toBe(true);
    });

    it('Â∫îËØ•Ëß£ÊûêÁâàÊú¨ÂèÇÊï∞ÁöÑÁÆÄÂÜôÂΩ¢Âºè', () => {
      const args = ['-v'];
      const options = cli.parseArgs(args);

      expect(options.version).toBe(true);
    });

    it('Â∫îËØ•Ëß£ÊûêÊúâÊïàÁöÑÊ∏©Â∫¶ÂèÇÊï∞', () => {
      const args = ['--temperature', '0.8'];
      const options = cli.parseArgs(args);

      expect(options.temperature).toBe(0.8);
    });

    it('Â∫îËØ•Ëß£ÊûêÊúâÊïàÁöÑÊúÄÂ§ß‰ª§ÁâåÊï∞ÂèÇÊï∞', () => {
      const args = ['--max-tokens', '1000'];
      const options = cli.parseArgs(args);

      expect(options.maxTokens).toBe(1000);
    });
  });

  describe('ÊµÅÂºèËÅäÂ§©ÂäüËÉΩ', () => {
    it('Â∫îËØ•Âú®Ê≤°ÊúâAIÂÆ¢Êà∑Á´ØÊó∂ÊäõÂá∫ÈîôËØØ', async () => {
      await expect(cli.streamChat('ÊµãËØïÊ∂àÊÅØ')).rejects.toThrow('AI ÂÆ¢Êà∑Á´ØÊú™ËÆæÁΩÆ');
    });

    it('Â∫îËØ•ÊâßË°åÂ∑•ÂÖ∑Ë∞ÉÁî®', async () => {
      const mockResponse = {
        choices: [{
          message: {
            toolCalls: [{
              function: {
                name: 'test_tool',
                arguments: '{"param": "value"}'
              }
            }]
          }
        }]
      };
      
      (mockAIClient.chatCompletionWithTools as jest.Mock).mockResolvedValue(mockResponse);
      (mockAIClient.executeToolCall as jest.Mock).mockResolvedValue({ result: 'success' });
      
      cli.setAIClient(mockAIClient);
      
      const result = await cli.chatWithTools('Hello');
      
      expect(mockAIClient.executeToolCall).toHaveBeenCalledWith(
        'test_tool',
        { param: 'value' }
      );
      expect(result).toEqual(mockResponse);
    });

    it('Â∫îËØ•ËÉΩÂ§üÂêØÂä®ÊµÅÂºèËÅäÂ§©', async () => {
      const mockStream = {
        [Symbol.asyncIterator]: async function* () {
          yield { choices: [{ delta: { content: 'Hello' } }] };
          yield { choices: [{ delta: { content: ' World' } }] };
        },
      };

      (mockAIClient.chatCompletionStream as jest.Mock).mockReturnValue(
        mockStream
      );
      cli.setAIClient(mockAIClient);

      const result = await cli.streamChat('Hello');

      expect(mockAIClient.chatCompletionStream).toHaveBeenCalledWith([
        { role: 'user', content: 'Hello' },
      ]);
      expect(result).toContain('Hello World');
    });

    it('Â∫îËØ•ËÉΩÂ§üÂ§ÑÁêÜÊµÅÂºèËÅäÂ§©ÈîôËØØ', async () => {
      const mockError = new Error('API ÈîôËØØ');
      (mockAIClient.chatCompletionStream as jest.Mock).mockImplementation(
        () => {
          throw mockError;
        }
      );
      cli.setAIClient(mockAIClient);

      await expect(cli.streamChat('Hello')).rejects.toThrow('API ÈîôËØØ');
    });

    it('Â∫îËØ•Â§ÑÁêÜÁ©∫ÂÜÖÂÆπÁöÑÊµÅÂºèÂìçÂ∫î', async () => {
      const mockStream = {
        [Symbol.asyncIterator]: async function* () {
          yield { choices: [{ delta: {} }] };
          yield { choices: [{ delta: { content: null } }] };
          yield { choices: [{ delta: { content: 'ÊµãËØï' } }] };
        },
      };

      (mockAIClient.chatCompletionStream as jest.Mock).mockReturnValue(
        mockStream
      );
      cli.setAIClient(mockAIClient);

      const result = await cli.streamChat('ÊµãËØïÊ∂àÊÅØ');

      expect(result).toBe('ÊµãËØï');
    });
  });

  describe('Â∑•ÂÖ∑Ë∞ÉÁî®ÂäüËÉΩ', () => {
    it('Â∫îËØ•ËÉΩÂ§üËé∑ÂèñÂèØÁî®Â∑•ÂÖ∑ÂàóË°®', () => {
      const mockTools = [
        {
          name: 'calculator',
          description: 'ËÆ°ÁÆóÂô®Â∑•ÂÖ∑',
          handler: jest.fn(),
          schema: {},
        },
      ];

      mockAIClient.getAvailableTools.mockReturnValue(mockTools);
      cli.setAIClient(mockAIClient);

      const tools = cli.getAvailableTools();
      expect(tools).toEqual(mockTools);
      expect(mockAIClient.getAvailableTools).toHaveBeenCalled();
    });

    it('Â∫îËØ•Âú®Ê≤°ÊúâAIÂÆ¢Êà∑Á´ØÊó∂ËøîÂõûÁ©∫Â∑•ÂÖ∑ÂàóË°®', () => {
      const tools = cli.getAvailableTools();
      expect(tools).toEqual([]);
    });

    it('Â∫îËØ•Âú®Ê≤°ÊúâAIÂÆ¢Êà∑Á´ØÊó∂ÊäõÂá∫ÈîôËØØÔºàÂ∏¶Â∑•ÂÖ∑Ë∞ÉÁî®ÁöÑËÅäÂ§©Ôºâ', async () => {
      await expect(cli.chatWithTools('ÊµãËØïÊ∂àÊÅØ')).rejects.toThrow('AI ÂÆ¢Êà∑Á´ØÊú™ËÆæÁΩÆ');
    });

    it('Â∫îËØ•ËÉΩÂ§üÊâßË°åÂ∏¶Â∑•ÂÖ∑Ë∞ÉÁî®ÁöÑÂØπËØù', async () => {
      const mockResponse = {
        id: 'test-response',
        object: 'chat.completion',
        created: Date.now(),
        model: 'gpt-4',
        choices: [
          {
            index: 0,
            message: {
              role: 'assistant' as const,
              content: 'ÊàëÊù•Â∏Æ‰Ω†ËÆ°ÁÆó',
              toolCalls: [
                {
                  id: 'call_123',
                  type: 'function' as const,
                  function: {
                    name: 'add',
                    arguments: '{"a": 2, "b": 3}',
                  },
                },
              ],
            },
            finishReason: 'tool_calls' as const,
          },
        ],
      };

      const mockToolResult = {
        tool_call_id: 'call_123',
        role: 'tool' as const,
        content: '5',
      };

      mockAIClient.chatCompletionWithTools.mockResolvedValue(
        mockResponse as any
      );
      mockAIClient.executeToolCall.mockResolvedValue(mockToolResult);
      cli.setAIClient(mockAIClient);

      const result = await cli.chatWithTools('ËÆ°ÁÆó 2 + 3');

      expect(mockAIClient.chatCompletionWithTools).toHaveBeenCalled();
      expect(mockAIClient.executeToolCall).toHaveBeenCalled();
      expect(result).toBeDefined();
    });

    it('Â∫îËØ•Â§ÑÁêÜÊ≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÁöÑÂìçÂ∫î', async () => {
      const mockResponse = {
        id: 'test-id',
        object: 'chat.completion',
        created: Date.now(),
        model: 'test-model',
        choices: [
          {
            index: 0,
            message: {
              role: 'assistant' as const,
              content: 'ÊôÆÈÄöÂõûÂ§çÔºåÊó†Â∑•ÂÖ∑Ë∞ÉÁî®',
            },
            finishReason: 'stop' as const,
          },
        ],
      };

      mockAIClient.chatCompletionWithTools.mockResolvedValue(mockResponse);

      cli.setAIClient(mockAIClient);
      const result = await cli.chatWithTools('ÊôÆÈÄöÈóÆÈ¢ò');

      expect(mockAIClient.chatCompletionWithTools).toHaveBeenCalledWith([
        { role: 'user', content: 'ÊôÆÈÄöÈóÆÈ¢ò' },
      ]);
      expect(mockAIClient.executeToolCall).not.toHaveBeenCalled();
      expect(result).toBe(mockResponse);
    });

    it('Â∫îËØ•Â§ÑÁêÜÁ©∫ÁöÑÂ∑•ÂÖ∑Ë∞ÉÁî®Êï∞ÁªÑ', async () => {
      const mockResponse = {
        id: 'test-id',
        object: 'chat.completion',
        created: Date.now(),
        model: 'test-model',
        choices: [
          {
            index: 0,
            message: {
              role: 'assistant' as const,
              content: 'ÂõûÂ§çÂÜÖÂÆπ',
              toolCalls: [],
            },
            finishReason: 'stop' as const,
          },
        ],
      };

      mockAIClient.chatCompletionWithTools.mockResolvedValue(mockResponse);

      cli.setAIClient(mockAIClient);
      const result = await cli.chatWithTools('ÊµãËØïÈóÆÈ¢ò');

      expect(mockAIClient.executeToolCall).not.toHaveBeenCalled();
      expect(result).toBe(mockResponse);
    });
  });

  describe('‰∫§‰∫íÂºèÊ®°Âºè', () => {
    it('Â∫îËØ•ËÉΩÂ§üÂêØÂä®‰∫§‰∫íÂºèÊ®°Âºè', async () => {
      // Mock inquirer
      const inquirer = require('inquirer');
      inquirer.prompt = jest
        .fn()
        .mockResolvedValueOnce({ message: 'Hello' })
        .mockResolvedValueOnce({ message: '/exit' });

      (mockAIClient.chatCompletionStream as jest.Mock).mockReturnValue({
        [Symbol.asyncIterator]: async function* () {
          yield { choices: [{ delta: { content: 'Hi there!' } }] };
        },
      });

      cli.setAIClient(mockAIClient);

      await cli.startInteractiveMode();

      expect(inquirer.prompt).toHaveBeenCalled();
    });

    it('Â∫îËØ•Â§ÑÁêÜ‰∫§‰∫íÂºèÊ®°Âºè‰∏≠ÁöÑÈîôËØØ', async () => {
      const inquirer = require('inquirer');
      inquirer.prompt = jest
        .fn()
        .mockResolvedValueOnce({ message: 'Hello' })
        .mockResolvedValueOnce({ message: '/exit' });
      
      // Ê®°ÊãüstreamChatÊäõÂá∫ÈîôËØØ
      const mockStreamChat = jest.spyOn(cli, 'streamChat')
        .mockRejectedValueOnce(new Error('ÊµãËØïÈîôËØØ'));
      
      cli.setAIClient(mockAIClient);
      
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      await cli.startInteractiveMode();
      
      expect(consoleSpy).toHaveBeenCalledWith('‚ùå ÈîôËØØ:', 'ÊµãËØïÈîôËØØ');
      
      consoleSpy.mockRestore();
      mockStreamChat.mockRestore();
    });
  });

  describe('Â∏ÆÂä©ÂíåÁâàÊú¨‰ø°ÊÅØ', () => {
    it('Â∫îËØ•ËÉΩÂ§üÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ', () => {
      const help = cli.getHelpText();
      expect(help).toContain('‰ΩøÁî®ÊñπÊ≥ï');
      expect(help).toContain('ÈÄâÈ°π');
      expect(help).toContain('Á§∫‰æã');
    });

    it('Â∫îËØ•ËÉΩÂ§üÊòæÁ§∫ÁâàÊú¨‰ø°ÊÅØ', () => {
      const version = cli.getVersion();
      expect(typeof version).toBe('string');
      expect(version.length).toBeGreaterThan(0);
    });
  });

  describe('ÈÖçÁΩÆÈ™åËØÅ', () => {
    it('Â∫îËØ•È™åËØÅÊúâÊïàÈÖçÁΩÆ', () => {
      const validConfig = {
        provider: 'openai' as const,
        apiKey: 'test-key',
        model: 'gpt-4',
        temperature: 0.7,
        maxTokens: 2000,
      };
      
      expect(() => cli.validateConfig(validConfig)).not.toThrow();
    });

    it('Â∫îËØ•ÊãíÁªùÁº∫Â∞ëAPIÂØÜÈí•ÁöÑÈÖçÁΩÆ', () => {
      const invalidConfig = {
        provider: 'openai' as const,
        apiKey: '',
        model: 'gpt-4',
        temperature: 0.7,
        maxTokens: 2000,
      };
      
      expect(() => cli.validateConfig(invalidConfig)).toThrow('ÈÖçÁΩÆÊó†Êïà: Áº∫Â∞ë API ÂØÜÈí•');
    });

    it('Â∫îËØ•ÊãíÁªùÁº∫Â∞ëÊ®°ÂûãÂêçÁß∞ÁöÑÈÖçÁΩÆ', () => {
      const invalidConfig = {
        provider: 'openai' as const,
        apiKey: 'test-key',
        model: '',
        temperature: 0.7,
        maxTokens: 2000,
      };
      
      expect(() => cli.validateConfig(invalidConfig)).toThrow('ÈÖçÁΩÆÊó†Êïà: Áº∫Â∞ëÊ®°ÂûãÂêçÁß∞');
    });
  });

  describe('ÈîôËØØÂ§ÑÁêÜ', () => {
    it('Â∫îËØ•ËÉΩÂ§üÂ§ÑÁêÜÊó†ÊïàÁöÑÈÖçÁΩÆ', () => {
      expect(() => {
        cli.validateConfig({} as any);
      }).toThrow('ÈÖçÁΩÆÊó†Êïà');
    });

    it('Â∫îËØ•ËÉΩÂ§üÂ§ÑÁêÜÁΩëÁªúÈîôËØØ', async () => {
      (mockAIClient.chatCompletionStream as jest.Mock).mockImplementation(
        () => {
          throw new Error('ÁΩëÁªúÈîôËØØ');
        }
      );
      cli.setAIClient(mockAIClient);

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      await cli.handleError(new Error('ÁΩëÁªúÈîôËØØ'));

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ÁΩëÁªúÈîôËØØ')
      );
      consoleSpy.mockRestore();
    });
  });
});
